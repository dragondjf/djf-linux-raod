Linux内存管理机制简介
====================
在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性，在这方面，区别于Windows的内存管理。主要特点是，无论物理内存有多大，Linux 都将其充份利用，将一些程序调用过的硬盘数据读入内存，利用内存读写的高速特性来提高Linux系统的数据访问性能。而Windows是只在需要内存时，才为应用程序分配内存，并不能充分利用大容量的内存空间。换句话说，每增加一些物理内存，Linux都将能充分利用起来，发挥了硬件投资带来的好处，而Windows只将其做为摆设，即使增加8GB甚至更大。

Linux的这一特性，主要是利用空闲的物理内存，划分出一部份空间，做为cache、buffers ，以此提高数据访问性能。

页高速缓存(cache)是Linux内核实现的一种主要磁盘缓存。它主要用来减少对磁盘的I/O操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。

磁盘高速缓存的价值在于两个方面：
+ 第一，访问磁盘的速度要远远低于访问内存的速度，因此，从内存访问数据比从磁盘访问速度更快。
+ 第二，数据一旦被访问，就很有可能在短期内再次被访问到。

下面来了解下Linux内存管理机制：

###一、物理内存和虚拟内存

我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。

**物理内存就是系统硬件提供的内存大小，是真正的内存**，相对于物理内存，在Linux下还有一个虚拟内存的概念，**虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）**。

作为物理内存的扩展，Linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。

Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。

要深入了解Linux内存运行机制，需要知道下面提到的几个方面：

Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。
Linux进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：Linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。
交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致Linux出现假死机、服务异常等问题，Linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。
因此，合理规划和设计Linux内存的使用，是非常重要的.

####二、内存的监控

作为一名Linux系统管理员，监控内存的使用状态是非常重要的，通过监控有助于了解内存的使用状态，比如内存占用是否正常，内存是否紧缺等等，监控内存最常使用的命令有free、top等，下面是某个系统free的输出：

    [root@linuxeye ~]# free
                 total       used       free     shared    buffers     cached 
    Mem:       3894036    3473544     420492          0      72972    1332348 
    -/+ buffers/cache:    2068224    1825812 
    Swap:      4095992     906036    3189956 
    
每个选项的含义：

第一行：

total：物理内存的总大小

used：已经使用的物理内存大小

free：空闲的物理内存大小

shared：多个进程共享的内存大小

buffers/cached：磁盘缓存的大小

第二行Mem：代表物理内存使用情况

第三行(-/+ buffers/cached)：代表磁盘缓存使用状态

第四行：Swap表示交换空间内存使用状态

free命令输出的内存状态，可以通过两个角度来查看：一个是从内核的角度来看，一个是从应用层的角度来看的。

**从内核的角度来查看内存的状态**

就是内核目前可以直接分配到，不需要额外的操作，即为上面free命令输出中第二行Mem项的值，可以看出，此系统物理内存有3894036K，空闲的内存只有420492K，也就是40M多一点，我们来做一个这样的计算：

        
3894036 – 3473544 = 420492

其实就是总的物理内存减去已经使用的物理内存得到的就是空闲的物理内存大小，注意这里的可用内存值420492并不包含处于buffers和cached状态的内存大小。

**如果你认为这个系统空闲内存太小，那你就错了，实际上，内核完全控制着内存的使用情况，Linux会在需要内存的时候，或在系统运行逐步推进时，将buffers和cached状态的内存变为free状态的内存，以供系统使用。**

**从应用层的角度来看系统内存的使用状态**

也就是Linux上运行的应用程序可以使用的内存大小，即free命令第三行 -/+ buffers/cached 的输出，可以看到，此系统已经使用的内存才2068224K，而空闲的内存达到1825812K，继续做这样一个计算：

420492＋（72972＋1332348）＝1825812

通过这个等式可知，应用程序可用的物理内存值是Mem项的free值加上buffers和cached值之和，也就是说，这个free值是包括buffers和cached项大小的，对于应用程序来说，buffers/cached占有的内存是可用的，因为buffers/cached是为了提高文件读取的性能，当应用程序需要用到内存的时候，buffers/cached会很快地被回收，以供应用程序使用。

**buffers与cached的异同**

在Linux 操作系统中
+ 当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据分发给应用程序；
+ 当需要往文件中写数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。

然而，如果有大量数据需要从磁盘读取到内存或者由内存写入磁盘时，系统的读写性能就变得非常低下，因为无论是从磁盘读数据，还是写数据到磁盘，都是一个很消耗时间和资源的过程，在这种情况下，Linux引入了buffers和cached机制。

**buffers与cached都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers与cached内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操作系统的性能。**

但buffers与cached缓冲的内容却是不同的。

+ buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages;
+ cached是用来给文件做缓冲。

更通俗一点说：**buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。**

为了验证我们的结论是否正确，可以通过vi打开一个非常大的文件，看看cached的变化，然后再次vi这个文件，感觉一下两次打开的速度有何异同，是不是第二次打开的速度明显快于第一次呢？

接着执行下面的命令：

    find /* -name '*.conf' 
看看buffers的值是否变化，然后重复执行find命令，看看两次显示速度有何不同。

**Linux操作系统的内存运行原理，很大程度上是根据服务器的需求来设计的，例如系统的缓冲机制会把经常使用到的文件和数据缓存在cached中，linux总是在力求缓存更多的数据和信息，这样再次需要这些数据时可以直接从内存中取，而不需要有一个漫长的磁盘操作，这种设计思路提高了系统的整体性能。**

####三、free命令字段详解

    DJF-linode➜  ~daemon  free
                 total       used       free     shared    buffers     cached
    Mem:       1015064     974720      40344        108      71612     675132
    -/+ buffers/cache:     227976     787088
    Swap:       524284       9456     514828

单位：KB

**Mem：表示物理内存的统计情况；**
**-/+ buffers/cached：从缓存的角度看物理内存的使用情况 **
**swap：表示硬盘上交换分区的使用情况**


+ Mem 行（第一行）数据说明：
       
       total：1015064。表示物理内存总大小。
       used：974720。表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。
       free：40344。表示未被分配的内存。
       shared：108。共享内存，一般系统不会用到。
       buffers：71612。系统分配但未被使用的buffers 数量。
       cached：675132。系统分配但未被使用的cache 数量。


+ -/+ buffers/cache 行（第二行）数据说明：
       
       used：227976，实际使用的buffers 与cache 总量，也是实际使用的内存总量。
       free: 787088, 未被使用的buffers 与cache 和未被分配的内存free之和，这就是系统当前实际可用内存。
 

 + swap 行(第三行):
        
       total： 524284  总共交换空间大小
       used:   9456    被使用交换空间大小
       free:   514828  可使用的交换空间大小

 
根据以上分析，可以得出一下结论：
1.  实际可用内存大小：

        Free（-/+ buffers/cache行）= Free(Mem)+buffers(Mem)+Cached(Mem);
        787088 = 40344 + 71612 + 675132
 
2.  已经分配的内存大小：
        Used(Mem) = Used(-/+ buffers/cache)+ buffers(Mem) + Cached(Mem)
        974720 = 227976 + 71612 + 675132
 
3.  物理内存总大小
        total（Mem） = used(-/+ buffers/cache) + free(-/+ buffers/cache)
        1015064 = 227976 + 787088

